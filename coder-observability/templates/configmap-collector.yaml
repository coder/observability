---
kind: ConfigMap
apiVersion: v1
metadata:
  name: {{ .Values.collector.agent.configMap.name }}
  namespace: {{ .Release.Namespace }}
data:
  config.river: |
    logging {
      level  = "debug"
      format = "logfmt"
    }

    // read the credentials secret for remote_write authorization
    // remote.kubernetes.secret "credentials" {
    //   namespace = "monitoring"
    //   name      = "primary-credentials-logs"
    // }

    discovery.kubernetes "pods" {
      role = "pod"
      // limit to pods on this node to reduce the amount you need to filter
      selectors {
       role  = "pod"
      }
    }

    discovery.relabel "pod_logs" {
      targets = discovery.kubernetes.pods.targets
       rule {
         source_labels = ["__meta_kubernetes_namespace"]
         target_label  = "namespace"
       }
       rule {
         source_labels = ["__meta_kubernetes_pod_name"]
         target_label  = "pod"
       }
       rule {
         source_labels = ["__meta_kubernetes_pod_container_name"]
         target_label  = "container"
       }
       rule {
         source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_label_app_kubernetes_io_name", "__meta_kubernetes_pod_label_app_kubernetes_io_component"]
         separator     = "/"
         target_label  = "job"
       }
       rule {
         source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
         separator     = "/"
         action        = "replace"
         replacement   = "/var/log/pods/*$1/*.log"
         target_label  = "__path__"
       }
       rule {
         action = "replace"
         source_labels = ["__meta_kubernetes_pod_container_id"]
         regex = "^(\\w+):\\/\\/.+$"
         replacement = "$1"
         target_label = "tmp_container_runtime"
       }
    }

    local.file_match "pod_logs" {
      path_targets = discovery.relabel.pod_logs.output
    }

    loki.source.file "pod_logs" {
      targets    = local.file_match.pod_logs.targets
      forward_to = [loki.process.pod_logs.receiver]
    }

    // basic processing to parse the container format. You can add additional processing stages
    // to match your application logs.
    loki.process "pod_logs" {
      stage.match {
        selector = "{tmp_container_runtime=\"containerd\"}"
        // the cri processing stage extracts the following k/v pairs: log, stream, time, flags
        stage.cri {}
        // Set the extract flags and stream values as labels
        stage.labels {
          values = {
            flags   = "",
            stream  = "",
          }
        }
      }

      // if the label tmp_container_runtime from above is docker parse using docker
      stage.match {
        selector = "{tmp_container_runtime=\"docker\"}"
        // the docker processing stage extracts the following k/v pairs: log, stream, time
        stage.docker {}

        // Set the extract stream value as a label
        stage.labels {
          values = {
            stream  = "",
          }
        }
      }

      // drop the temporary container runtime label as it is no longer needed
      stage.label_drop {
        values = ["tmp_container_runtime"]
      }

      forward_to = [loki.write.loki.receiver]
    }

    // TODO reference release name
    loki.write "loki" {
      endpoint {
        url = "http://{{ include "loki.fullname" .Subcharts.logs }}-gateway.{{ .Release.Namespace }}.svc.cluster.local/loki/api/v1/push"
        // basic_auth {
        //   username = nonsensitive(remote.kubernetes.secret.credentials.data["username"])
        //   password = remote.kubernetes.secret.credentials.data["password"]
        // }
      }
    }